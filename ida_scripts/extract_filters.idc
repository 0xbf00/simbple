/*
 * Copyright (C) Jakob Rieck 2018
 *
 * Extract sandbox filter related information, compatible with the SBPL interpreter
 * presented.
 *
 * This script generates two output files: arguments.c, which contains the named arguments
 * that are known to the sandbox and definition.c, which contains the filter definitions
 * extracted from libsandbox.
 *
 * Iff there are newly added named arguments for certain filters or named arguments for certain
 * filters have been removed, it will be needed to change sb/filters/arguments.h accordingly!
 *
 * Note that the current sb/filters/definition.c file contains information about derived filters, which
 * is not generated by this script. Make sure to properly merge the two files after running the script.
 */

#include <idc.idc>

#define true 1

/*
 * Convert the current string into a valid identifier in C programs.
 * This function assumes a operation is given as input, meaning that
 * the only characters that are assumed to be in this string are
 * letters, stars (*) and hyphons (-).
 */
static make_c_identifier(str)
{
    auto result = "";

    auto len = strlen(str);
    auto i = 0;
    for (i = 0; i < len; i = i + 1) {
        if (str[i] == "*") {
            result = result + "_all";
        } else if (str[i] == "-") {
            result = result + "_";
        } else {
            result = result + str[i];
        }
    }

    return result;
}

/*
 * Get the number of currently registered filters
 */
static get_filter_count()
{
    auto filter_base = LocByName("_filter_info");
    if (filter_base == BADADDR) {
        return 0;
    }

    auto offset = 0x0;
    auto filter_count = 0x0;

    while (true) {
        auto current_name = Name(filter_base + offset);

        // If the current memory location has a name and it is not
        // the one we are looking for, stop (because then we reached another
        // memory structure and should stop)
        if (current_name != "" && current_name != "_filter_info") {
            break;
        }

        filter_count = filter_count + 1;
        offset = offset + 0x20;
    }

    return filter_count;
}

/*
 * Get the base address of the filter info structure for the specified
 * index. Returns BADADDR if the operation is unsuccessful.
 */
static get_filter_base(idx)
{
    auto filter_base = LocByName("_filter_info");
    if (filter_base == BADADDR) {
        return BADADDR;
    }

    // 0x20 is the size of the filter_info structure
    return filter_base + 0x20 * idx;
}

/*
 * Get the name of a filter (given its index).
 * Returns "" if the index is invalid.
 */
static get_filter_name(idx)
{
    auto name_loc = Qword(get_filter_base(idx));
    if (name_loc == 0x0) {
        return "NULL";
    }

    return GetString(name_loc, -1, ASCSTR_C);
}

static get_filter_category(idx)
{
    auto filter_base = get_filter_base(idx);
    auto category_loc = Qword(filter_base + 0x8);
    if (category_loc == 0x0) {
        return "NULL";
    }

    return GetString(category_loc, -1, ASCSTR_C);
}

static get_filter_accepted_type(idx)
{
    auto filter_base = get_filter_base(idx);

    auto raw_value = Byte(filter_base + 0x10);
    if (raw_value == 0x1) {
        return "SB_VALUE_TYPE_BOOL";
    } else if (raw_value == 0x2) {
        return "SB_VALUE_TYPE_BITFIELD";
    } else if (raw_value == 0x3) {
        return "SB_VALUE_TYPE_INTEGER";
    } else if (raw_value == 0x4) {
        return "SB_VALUE_TYPE_STRING";
    } else if (raw_value == 0x5) {
        return "SB_VALUE_TYPE_PATTERN_LITERAL";
    } else if (raw_value == 0x6) {
        return "SB_VALUE_TYPE_PATTERN_PREFIX";
    } else if (raw_value == 0x7) {
        return "SB_VALUE_TYPE_PATTERN_SUBPATH";
    } else if (raw_value == 0x8) {
        return "SB_VALUE_TYPE_PATTERN_REGEX";
    } else if (raw_value == 0x9) {
        return "SB_VALUE_TYPE_REGEX";
    } else if (raw_value == 0xa) {
        return "SB_VALUE_TYPE_NETWORK";
    } else {
        return "UNHANDLED_CASE";
    }
}

/*
 * WIP name. Introduced in macOS Mojave.
 * Shortcut to check whether two or more filters fundamentally
 * contradict eachother. The only example thus far are the
 * global-name and local-name filters...
 */
static get_filter_is_contrary(idx)
{
    auto filter_base = get_filter_base(idx);
    auto is_contrary = Byte(filter_base + 0x11);

    return (is_contrary ? "1" : "0");
}

/*
 * WIP name. Introduced in macOS Mojave.
 * The exact purpose of this field has not been
 * reverse engineered thus far.
 */
static get_filter_cost_factor(idx)
{
    auto filter_base = get_filter_base(idx);
    auto cost_estimate = Word(filter_base + 0x12);

    return sprintf("%d", cost_estimate);
}

static get_filter_prerequisite(idx)
{
    auto filter_base = get_filter_base(idx);

    auto prerequisite_value = Dword(filter_base + 20);
    if (prerequisite_value == 0x0) {
        return "FILTER_NO_REQUISITE";
    } else {
        return sprintf("%d", prerequisite_value);
    }
}

/*
 * Gets the pointer to the named arguments of the filter with index idx
 * (This pointer is NULL for those that have no named arguments)
 */
static get_filter_named_arguments(idx)
{
    auto filter_base = get_filter_base(idx);

    return Qword(filter_base + 24);
}

static ask_mandatory_outfile(mask, msg)
{
    auto outfile_name = AskFile(1, mask, msg);
    if (outfile_name == 0) {
        return 0;
    }

    auto outfile_f = fopen(outfile_name, "w");
    return outfile_f;
}

/*
 * This function dumps the named arguments specified for a certain
 * filter. To do this, the function needs three arguments:
 *  - The output file to which to write the filter definitions
 *  - The name of the filter (this is used to generate the appropriate variable name)
 *  - The offset where the arguments start at.
 */
static dump_named_arguments(args_file, filter_name, args_start)
{
    auto variable_name = make_c_identifier(filter_name) + "_args";

    if (args_start == 0x0) {
        return;
    }

    auto current_offset = 0;

    // Write starting row
    fprintf(args_file, "static const named_argument %s[] = {\n", variable_name);

    while (true) {
        auto str_offset = Qword(args_start + current_offset);
        auto int_value  = Word(args_start + current_offset + 0x8);

        if (str_offset == 0x0) {
            break;
        }

        auto str = GetString(str_offset, -1, ASCSTR_C);
        fprintf(args_file, "    { \"%s\", %d },\n", str, int_value);

        current_offset = current_offset + 0x10;
    }

    // Write finishing row and end definition
    fprintf(args_file, "    { NULL, 0 }\n};\n");
}

static dump_filter_info(filter_file, filter_idx)
{
    // Check for special, first filter that is not useful
    if (get_filter_name(filter_idx) == "NULL") {
        fprintf(filter_file, "    { 0 },\n");
        return;
    }
    
    fprintf(filter_file, "    {\n");
    fprintf(filter_file, "        .name = \"%s\",\n", get_filter_name(filter_idx));
    fprintf(filter_file, "        .category = \"%s\",\n", get_filter_category(filter_idx));
    fprintf(filter_file, "        .argument_type = %s,\n", get_filter_accepted_type(filter_idx));
    fprintf(filter_file, "        .is_contrary = %s,\n", get_filter_is_contrary(filter_idx));
    fprintf(filter_file, "        .cost_factor = %s,\n", get_filter_cost_factor(filter_idx));
    fprintf(filter_file, "        .prerequisite = %s,\n", get_filter_prerequisite(filter_idx));

    auto filter_arguments = get_filter_named_arguments(filter_idx);
    if (filter_arguments) {
        // Re-generate name for the filter arguments.
        auto arg_name = make_c_identifier(get_filter_name(filter_idx)) + "_args";
        fprintf(filter_file, "        .named_arguments = %s,\n", arg_name);
    }

    fprintf(filter_file, "    },\n");
}

static main()
{
    auto i = 0;
    auto cnt_filters = get_filter_count();

    // // Where to save the arguments file to
    // auto args_file = ask_mandatory_outfile("*.c", "Where would you like to save the argument.c file to?");
    // if (args_file == 0) {
    //     Message("Invalid or no file provided.\n");
    //     return;
    // }

    // Where to save filter definitions to
    auto filter_file = ask_mandatory_outfile("*.c", "Where would you like to save the filter definition file to?");
    if (filter_file == 0) {
        Message("Invalid or no file provided.\n");
        return;
    }

    Message("Found %d filters\n", cnt_filters);

    // Starting include line
    fprintf(filter_file, "#include \"filters.h\"\n\n");

    // Write named arguments to file
    for (i = 0; i < cnt_filters; i = i + 1) {
        auto named_arguments = get_filter_named_arguments(i);
        if (named_arguments) {
            dump_named_arguments(filter_file, get_filter_name(i), named_arguments);
        }
    }

    // Write filter info header.
    fprintf(filter_file, "static const filter_info_t filter_infos[] = {\n");

    for (i = 0; i < cnt_filters; i = i + 1) {
        dump_filter_info(filter_file, i);
    }

    // Write filter info footer
    fprintf(filter_file, "};\n");

    fclose(filter_file);
//    fclose(args_file);
}